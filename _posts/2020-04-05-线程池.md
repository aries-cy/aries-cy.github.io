---
title: 线程池
categories: [concurrent]
comments: true
---

#### 线程池
---
* 在JDK中，有4种构造线程池的方式：
    * newFixedThreadPool -> 固定数量的线程
    * newSingleThreadExecutor -> 只有一个线程的线程池
    * newCachedThreadPool -> 线程数量不一定，不停的创建线程，用完了以后进行回收
    * newScheduledThreadPool -> 提交任务后，在指定的时间去执行

##### newFixedThreadPool
---
选择`newFixedThreadPool`简单的来分析一下，写一个程序来看一下`newFixedThreadPool`这个线程池：
```java
public static void main(String[] args) throws Exception {
        ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) {
            newFixedThreadPool.execute(() -> {
                System.out.println("线程名称 -> " + Thread.currentThread().getName());
            }); 
        }
        newFixedThreadPool.shutdown();
    }
```
控制台输出如下：
![executor_1](https://aries-cy.github.io/assets/note_img/executor_1.jpg)
可以看到控制台中只有3个线程。

`newFixedThreadPool`的构造函数：
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
顺着往下看`ThreadPoolExecutor`：
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```
上面的代码可以看到线程池构造方法的参数：
* corePoolSize：核心线程池的大小，当提交一个任务到线程池时，线程池会创建一个线 程来执行任务
* maximumPoolSize：线程池的最大线程数，线程池里的线程用完了且队列满了，也会创建一些线程，单不大于该参数
* keepAliveTime：如果线程数量超过了corePoolSize，超出部分的线程，就会在空闲keepAliveTime后，被释放掉
* unit：时间单位
* workQueue：线程池的等待队列
* threadFactory：线程工厂，创建线程池的时候，可以指定一个线程工厂，按照自己的方式创建线程
* RejectedExecutionHandler：如果线程池里的线程都在执行任务，然后等待队列满了，此时增加额外线程也达到了maximumPoolSize指定的数量了，这个时候实在无法承载更多的任务了，就会执行拒绝策略



##### 线程池执行任务的流程
---
* 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）
* 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue
* 如果无法将任务加入BlockingQueue（队列已满，且没有达到最大线程数），则创建新的线程来处理任务（注意，执 行这一步骤需要获取全局锁）
* 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法

##### 合理的使用线程池
---
* CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池
* 由于IO密集型任务线程并不是一直在执行任务，则应配 置尽可能多的线程，如2*Ncpu
